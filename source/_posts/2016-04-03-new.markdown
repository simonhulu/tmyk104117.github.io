---
layout: post
title: "new"
date: 2016-04-03 10:06:24 +0800
comments: true
categories: 
---
# 把方法作为回调提供 #
很多习惯于ES6的用户反而不理解在ES5下可以这么做

{% highlight js %}
//ES6
var PostInfo = React.createClass({
	handleOptionsButtonClick:function(e){
		//Here
		this.setState({showOptionsModal:true});
	},
	render:function(){
		return(
			<TouchableHighlight onPress={this.handleOptionsButtonClick}>
				<Text>{this.props.label}</Text>
			</TouchableHighlight>
		)
	},
});
{% endhighlight js %}

在ES5下,React.createClass会把所有的方法都bind一遍,这样可以提交到任意的地方作为回调函数,而this不会变化。但官方现在逐步认为这反而是不标准,不易理解的。
在ES6下,你需要通过bind来绑定this引用,或者使用箭头函数(它会绑定当前scope的this引用)来调用
{% highlight js %}
//ES6
class PostInfo extends React.Component
{
	handleOptionsButtonClick(e){
		this.setState({showOptionsModal:true});
	}
	render(){
		return(
			<TouchableHight onPress={this.handleOptionsButtonClick.bind(this)}
							onPress={e=>this.handleOptionsButtonClick(e)}>
				<Text>{this.props.label}</Text>
			</TouchableHight>
		)
	},
}
{% endhighlight js %}
<font color="red">箭头函数</font>实际上是在这里定义了一个临时的函数,箭头函数的箭头<font color="red">"=>"</font>之前是一个空括号,单个的参数名,或用括号括起的多个参数名,而箭头之后可以是一个表达式(作为函数的返回值),或者是用花括号括起的函数体(需要自行通过return来返回值,否则返回的时undefined).
{% highlight js %}
//箭头函数的例子
()=>1
v=>v+1
(a,b)=>a+b
()=>{
	alert("foo");
}
e=>{
	if(e==0)
	{
		return 0 ;
	}
	return 1000/e;
}
{% endhighlight js %}
需要注意的是,不论是bind还是箭头函数,每次被执行都返回的是一个新的函数引用,因此如果你需要函数的引用去做一些别的事情(譬如卸载监听器),那你必须是保存这个引用
{% highlight js %}
//错误的做法
class PauseMenu extends React.Component{
	compoentWillMount(){
		AppStateIOS.addEventListener('change',this.onAppPaused.bind(this));
	}
	componentDidUnmount(){
		AppStateIOS.removeEventListener('change',this.onAppPaused.bind(this));
	}
	onAppPaused(event){

	}
}

//正确的做法
class PauseMenu extends React.Component{
	constructor(props){
		super(props);
		this._onAppPaused = this.onAppPaused.bind(this);
	}
	componentWillMount(){
		AppStateIOS.addEventListener('change',this._onAppPaused);
	}
	componentDidUnmount(){
		AppStateIOS.removeEventListener('change',this._onAppPaused);
	}
	onAppPaused(event){

	}
}
//或者
// 正确的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener('change', this.onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener('change', this.onAppPaused);
    }
    onAppPaused = (event) => {
        //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针
    }
}
{% endhighlight js %}
{% img http://7xs6cr.com1.z0.glb.clouddn.com/qrcode_for_gh_6f7e12337ad2_258.jpg %}
